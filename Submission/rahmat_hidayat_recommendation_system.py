# -*- coding: utf-8 -*-
"""Rahmat Hidayat_Recommendation_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SdYkJVJrAZMvTIavLGmA9eoQJv6RfJ6v

# Recomendation System
**DATA DIRI:**

- nama lengkap: RAHMAT HIDAYAT

- ID Dicoding: mc013d5y1559

- email: imjustrahmat2722@gmail.com

# 1. Import Library
"""

!pip install scikit-surprise

# Import library untuk manipulasi data
import pandas as pd
import numpy as np

# Import library untuk visualisasi
import matplotlib.pyplot as plt
import seaborn as sns

# Import library untuk pemrosesan teks dan metrik(content base ffiltering)
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Import library untuk collaborative filtering
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from scipy.sparse import csr_matrix
from sklearn.decomposition import TruncatedSVD
from surprise import SVD
from surprise.model_selection import cross_validate
from surprise.model_selection import train_test_split
from surprise import Reader
from surprise.accuracy import mae
from surprise import Dataset
import warnings
warnings.filterwarnings('ignore')

"""Import library yang digunakan untuk data preparation, understanding, serta modeling dan evaluasi

# 3. Data Understanding
"""

# @title Data Loading
movies = pd.read_csv('https://drive.google.com/uc?id=1eql1qRJzay8ZPHUbL5iJozTnfxtfQ3Fg')
ratings = pd.read_csv('https://drive.google.com/uc?id=1-xwVnHvptp9zl2AYg0gpzpD6or7FTiZE')

# @title menampilkan 5 baris awal data
print("Data Movies:")
print(movies.head())
print("\nData Ratings:")
print(ratings.head())

# @title melihat informasi dasar dataset
print("Info Dataset Movies:")
print(movies.info())
print("\nInfo Dataset Ratings:")
print(ratings.info())

"""Pertama untuk Data Understanding saya melihat informasi dasar dataset terlebih dahulu untuk mengenathui tipedata serta jumlah kolom dan baris setiap data."""

# @title cek missing value dan duplikat
print("Jumlah missing value pada dataset movies:")
print(movies.isnull().sum())
print("\nJumlah missing value pada dataset ratings:")
print(ratings.isnull().sum())

print("Jumlah duplikat pada dataset movies:")
print(movies.duplicated().sum())
print("\nJumlah duplikat pada dataset ratings:")
print(ratings.duplicated().sum())

"""Tidak ada Missing Value dan duplikat pada Data, sehingga tidak diperlkan penanganan lebih lanjut

## 3.1 Exloration Data Analysis
"""

# @title Deskripsi Statistik
print("Deskripsi Statistik Dataset Movies:")
print(movies.describe())
print("\nDeskripsi Statistik Dataset Ratings:")
print(ratings.describe())

"""KESIMPULAN :

ðŸ“ Dataset: movies.csv
ðŸ”— URL/Tautan Sumber Data

Dataset ini diunduh melalui tautan berikut:
https://drive.google.com/uc?id=1eql1qRJzay8ZPHUbL5iJozTnfxfQ3Fg
ðŸ”¢ Jumlah Baris dan Kolom

    Jumlah data: 9.742 baris dan 3 kolom

ðŸ§¹ Kondisi Data

    Missing value: Tidak ditemukan nilai kosong pada seluruh kolom.

    Duplikat: Tidak terdapat baris yang sama persis (duplikat).

    Outlier: Tidak relevan karena semua data bersifat kategorikal.

ðŸ“Œ Uraian Seluruh Fitur

    movieId: ID unik untuk setiap film.

    title: Judul film beserta tahun rilis, misalnya Toy Story (1995).

    genres: Kategori genre film yang dipisahkan dengan tanda pipe (|), misalnya Adventure|Animation|Children|Comedy|Fantasy.

ðŸ“ Dataset: ratings.csv
ðŸ”— URL/Tautan Sumber Data

Dataset ini diunduh melalui tautan berikut:
https://drive.google.com/uc?id=1-xwVnHvpt9zl2AYg0gpzpD6or7FTiZE
ðŸ”¢ Jumlah Baris dan Kolom

    Jumlah data: 100.836 baris dan 4 kolom

ðŸ§¹ Kondisi Data

    Missing value: Tidak ditemukan nilai kosong.

    Duplikat: Tidak terdapat duplikasi baris.

    Outlier: Tidak ditemukan nilai rating di luar rentang normal (semua berada di antara 0.5 hingga 5.0).

ðŸ“Œ Uraian Seluruh Fitur

    userId: ID unik pengguna yang memberikan rating.

    movieId: ID film yang dirujuk, sesuai dengan movieId pada movies.csv.

    rating: Nilai penilaian yang diberikan oleh pengguna terhadap film, dalam skala 0.5 hingga 5.0.

    timestamp: Waktu pemberian rating dalam format Unix timestamp.
"""

# @title Distribusi Rating
plt.figure(figsize=(8, 5))
sns.histplot(ratings['rating'], bins=20, kde=True, color='blue')
plt.title('Distribusi Rating')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.grid(True)
plt.show()

"""## Insight Visualisasi Rating Film

* **Rating Terbanyak:** Sebagian besar pengguna memberikan rating di sekitar nilai 4, menunjukkan bahwa secara umum mayoritas film cukup memuaskan.
* **Distribusi:** Distribusi rating cenderung miring ke kanan (right-skewed), yang berarti ada lebih banyak rating tinggi dibandingkan rating rendah. Hal ini mengindikasikan bahwa mayoritas film memiliki kualitas yang cukup baik, namun masih ada potensi untuk ditingkatkan.
* **Rating Ekstrem:**
  * **Rating Rendah:** Hanya sedikit pengguna yang memberikan rating sangat rendah (mendekati 1), menunjukkan bahwa masalah serius pada mayoritas film mungkin jarang terjadi.
  * **Rating Tinggi:** Meskipun ada jumlah yang signifikan dari rating tinggi (mendekati 5), namun tidak sebanyak rating di sekitar nilai 4. Ini bisa menjadi indikator bahwa ada beberapa aspek mayoritas film yang masih perlu ditingkatkan untuk mencapai kepuasan pelanggan maksimal.
* **Kesimpulan:** Secara keseluruhan, hasil visualisasi menunjukkan bahwa mayoritas film memiliki kualitas yang baik dan cukup digemari oleh pengguna. Namun, terdapat peluang untuk meningkatkan kepuasan pelanggan dengan fokus pada aspek-aspek yang dapat mendorong lebih banyak pengguna memberikan rating 5.
"""

# @title TOP 10 film dengan rating tertinggi
average_ratings = ratings.groupby('movieId')['rating'].mean().reset_index(name='average_rating')
average_ratings = average_ratings.merge(movies, on='movieId')
top_rated_movies_avg = average_ratings.sort_values(by='average_rating', ascending=False).head(10)
print(top_rated_movies_avg[['title', 'average_rating']])

# Visualisasi rata-rata rating
plt.figure(figsize=(12,6))
sns.barplot(x='average_rating', y='title', data=top_rated_movies_avg, palette='coolwarm')
plt.title('Top 10 Film Berdasarkan Rata-Rata Rating', fontsize=16)
plt.xlabel('Rata-Rata Rating', fontsize=12)
plt.ylabel('Film', fontsize=12)
plt.show()

"""Berdasarkan analisis terhadap film-film yang masuk dalam top 10, dapat diambil beberapa kesimpulan menarik:

* **Dominasi Film Tahun 2000-an:** Mayoritas film yang menempati posisi teratas dirilis pada dekade 2000-an. Hal ini mengindikasikan bahwa film-film yang diproduksi pada periode ini secara umum berhasil meraih rating tinggi dan mendapatkan apresiasi dari penonton.
* **Kepopuleran Film Klasik:** Beberapa film yang dirilis pada dekade 1970-an dan 1980-an masih mampu bersaing dan masuk dalam daftar top 10. Fakta ini menunjukkan bahwa film-film klasik tetap memiliki daya tarik tersendiri bagi penonton lintas generasi.
* **Minimnya Representasi Film Tahun 1990-an:** Menariknya, tidak ada satupun film yang dirilis pada dekade 1990-an yang masuk dalam top 10. Hal ini bisa mengindikasikan beberapa kemungkinan, seperti:
  * **Standar Penonton yang Lebih Tinggi:** Penonton pada dekade 2000-an mungkin memiliki standar yang lebih tinggi terhadap kualitas film, sehingga film-film tahun 1990-an dianggap kurang memenuhi ekspektasi.
  * **Kurangnya Pengujian Waktu:** Film-film yang dirilis pada dekade 1990-an mungkin belum memiliki waktu yang cukup untuk teruji oleh waktu dan mendapatkan apresiasi yang lebih luas.
  * **Faktor Lain:** Bisa jadi ada faktor lain yang mempengaruhi, seperti perubahan tren industri film atau keterbatasan data yang digunakan dalam analisis.

**Kesimpulan:**

Analisis ini menunjukkan bahwa preferensi penonton film terus berubah seiring waktu. Meskipun film-film klasik tetap dihargai, film-film yang dirilis pada dekade 2000-an secara umum lebih dominan dalam daftar top 10. Hal ini memberikan gambaran tentang tren industri film dan preferensi penonton pada periode tersebut.
"""

# @title Julah Rating perfilm
# Menghitung jumlah rating per film
rating_counts = ratings.groupby('movieId').size().reset_index(name='rating_count')
top_rated_movies = rating_counts.sort_values(by='rating_count', ascending=False).head(10)
top_rated_movies = top_rated_movies.merge(movies, on='movieId')
print(top_rated_movies[['title', 'rating_count']])

# Visualisasi jumlah rating per film
plt.figure(figsize=(12,6))
sns.histplot(rating_counts['rating_count'], bins=50, kde=True, color='purple')
plt.title('Distribusi Jumlah Rating per Film', fontsize=16)
plt.xlabel('Jumlah Rating per Film', fontsize=12)
plt.ylabel('Frekuensi', fontsize=12)
plt.show()

"""Berdasarkan analisis histogram distribusi jumlah rating film, dapat disimpulkan sebagai berikut:

* **Mayoritas Film Memiliki Rating Rendah:** Sebagian besar film dalam dataset ini hanya memiliki sedikit rating, dengan rentang 0-10 rating per film mendominasi distribusi . Hal ini menunjukkan bahwa sebagian besar film mungkin merupakan film independen, film niche, atau film yang kurang dikenal publik.
* **Ekor Panjang ke Kanan:** Histogram menunjukkan pola ekor panjang ke kanan, di mana semakin banyak rating yang diterima sebuah film, semakin sedikit jumlah film yang berada dalam kategori tersebut. Ini mengindikasikan adanya beberapa film yang sangat populer dan berhasil mengumpulkan banyak rating, namun jumlah film seperti ini relatif sedikit dibandingkan dengan film-film yang kurang populer.
* **Distribusi Eksponensial:** Distribusi jumlah rating secara keseluruhan mengikuti pola eksponensial. Artinya, frekuensi film dengan jumlah rating tinggi menurun secara drastis dibandingkan dengan film yang memiliki jumlah rating rendah. Hal ini merupakan pola yang umum ditemukan dalam distribusi banyak fenomena, termasuk popularitas film.

"""

# @title Distribusi rating user

user_rating_counts = ratings.groupby('userId').size().reset_index(name='rating_count_user')

# Menampilkan pengguna dengan rating terbanyak
top_users = user_rating_counts.sort_values(by='rating_count_user', ascending=False).head(10)
print(top_users)

# Visualisasi distribusi rating per pengguna
plt.figure(figsize=(12,6))
sns.histplot(user_rating_counts['rating_count_user'], bins=50, kde=True, color='orange')
plt.title('Distribusi Rating per Pengguna', fontsize=16)
plt.xlabel('Jumlah Rating per Pengguna', fontsize=12)
plt.ylabel('Frekuensi', fontsize=12)
plt.show()

"""Berdasarkan visualisasi distribusi rating per pengguna, dapat diambil beberapa kesimpulan sebagai berikut:

### Karakteristik Distribusi
* **Asimetris:** Distribusi rating per pengguna menunjukkan bentuk yang asimetris, dengan ekor panjang ke kanan. Ini berarti sebagian besar pengguna memberikan rating dalam jumlah yang relatif sedikit, sementara hanya sedikit pengguna yang sangat aktif dalam memberikan rating.
* **Ekor Kanan:** Adanya ekor kanan pada distribusi mengindikasikan keberadaan sejumlah kecil pengguna yang memberikan kontribusi sangat signifikan terhadap total rating. Pengguna-pengguna ini dapat dianggap sebagai pengguna super aktif.

### Implikasi
* **Aktivitas Pengguna:**
  * **Mayoritas Pengguna Pasif:** Sebagian besar pengguna hanya memberikan sedikit rating, menunjukkan tingkat aktivitas yang rendah dalam platform. Hal ini bisa disebabkan oleh berbagai faktor, seperti kurangnya minat, kesulitan dalam memberikan rating, atau kurangnya pemahaman tentang manfaat memberikan rating.
  * **Pengguna Super Aktif:** Sebaliknya, terdapat segmen kecil pengguna yang sangat aktif dalam memberikan rating. Pengguna ini memiliki peran penting dalam membentuk distribusi keseluruhan dan seringkali memberikan umpan balik yang berharga bagi platform.

"""

# @title Korelasi Rating dengan Jumlah Rating
rating_data = ratings.groupby('movieId').agg({'rating': 'mean', 'userId': 'count'}).rename(columns={'userId': 'num_ratings'})
plt.figure(figsize=(8, 6))
sns.scatterplot(x='num_ratings', y='rating', data=rating_data, color='green')
plt.title('Korelasi antara Jumlah Rating dan Rating Rata-rata')
plt.xlabel('Jumlah Rating')
plt.ylabel('Rating Rata-rata')
plt.grid(True)
plt.show()

"""## Analisis Korelasi: Jumlah Rating vs. Rating Rata-rata

**Visualisasi** menunjukkan adanya **korelasi positif yang lemah** antara jumlah rating yang diterima oleh suatu produk atau layanan dengan rating rata-rata yang diperolehnya.

### Temuan Utama:
* **Tren Umum:** Terdapat kecenderungan umum bahwa semakin banyak rating yang diterima oleh suatu produk atau layanan, maka cenderung memiliki rating rata-rata yang lebih tinggi. Ini mengindikasikan bahwa jumlah rating dapat menjadi salah satu faktor yang mempengaruhi persepsi kualitas produk atau layanan di mata user.
* **Sebaran Data:** Sebagian besar data terkonsentrasi pada area dengan jumlah rating yang rendah, menunjukkan bahwa banyak produk atau layanan yang belum mendapatkan banyak ulasan dari user.
* **Pengecualian:** Terdapat beberapa titik data yang tidak mengikuti tren umum, di mana produk atau layanan dengan jumlah rating tinggi justru memiliki rating rata-rata yang rendah, atau sebaliknya. Ini mengindikasikan bahwa jumlah rating bukanlah satu-satunya faktor yang menentukan rating rata-rata. Faktor lain seperti kualitas produk itu sendiri, bias dalam memberikan rating, atau timing pemberian rating juga dapat mempengaruhi.

# 4. Data Preparation
"""

# @title 4.1 Data Preparation untuk Collaborative Filtering
# Format data untuk Surprise library
reader = Reader(rating_scale=(0.5, 5.0))  # Skala rating dari dataset
data = Dataset.load_from_df(ratings[['userId', 'movieId', 'rating']], reader)

# Bagi data menjadi training dan testing
trainset, testset = train_test_split(data, test_size=0.2)

"""Tahap **persiapan data** untuk model **Collaborative Filtering** menggunakan **Surprise library**, yang dirancang untuk memprediksi rating berdasarkan pola preferensi pengguna. Berikut penjelasannya:

1. **Format Data**  
   - `Reader`: Mengatur skala rating (0.5 hingga 5.0) sesuai dengan dataset, agar Surprise dapat memahami struktur data.
   - `Dataset.load_from_df`: Mengonversi data rating dari DataFrame (`ratings`) menjadi format internal Surprise yang dibutuhkan untuk model rekomendasi.

2. **Pembagian Data**  
   - `train_test_split`: Memisahkan data menjadi **training set** (80%) dan **testing set** (20%).  
   - **Alasan**:
     - Training set digunakan untuk melatih model.
     - Testing set digunakan untuk mengevaluasi performa model dengan data yang belum pernah dilihat.  
   Metode ini membantu mengukur generalisasi model dan menghindari overfitting.
"""

# @title Data Preparation untuk content base filtering
# Pastikan data 'genres' diolah menjadi string bersih
movies['genres'] = movies['genres'].str.replace('|', ' ')
print("\nData Movies setelah memproses kolom genres:")
print(movies.head())

# Vektorisasi genre menggunakan TF-IDF
tfidf_vectorizer = TfidfVectorizer()
tfidf_matrix = tfidf_vectorizer.fit_transform(movies['genres'])
print("\nHasil vektorisasi genre (matriks TF-IDF):")
print(tfidf_matrix.toarray())  # Menampilkan matriks TF-IDF sebagai array

"""### **Penjelasan Tahapan Data Preparation**

1. **Pembersihan Kolom `genres`**  
   - Pada tahap ini, data dalam kolom `genres` yang semula menggunakan simbol `|` sebagai pemisah diubah menjadi spasi dengan perintah:  
     ```python
     movies['genres'] = movies['genres'].str.replace('|', ' ')
     ```
   - Tujuan utama langkah ini adalah untuk membuat representasi teks yang lebih bersih dan mudah dipahami, baik untuk proses selanjutnya seperti analisis maupun oleh model rekomendasi itu sendiri.
   - Hasil transformasi ini juga memungkinkan sistem untuk mengenali genre sebagai satuan teks yang terpisah (contoh: "Action Adventure Comedy" alih-alih "Action|Adventure|Comedy").

2. **Visualisasi Data Setelah Praproses**  
   - Data ditampilkan dengan tujuannya adalah untuk memverifikasi apakah data sudah diolah sesuai harapan. Hal ini penting untuk memastikan integritas data sebelum melangkah ke tahapan selanjutnya.

3. **Representasi Data dengan Vektorisasi**  
   - **Vektorisasi**: Data teks dari kolom `genres` diubah menjadi representasi numerik melalui teknik **TF-IDF (Term Frequency-Inverse Document Frequency)**
   - Hasil vektorisasi berupa matriks yang menunjukkan bobot numerik dari setiap genre pada setiap film. Matriks ini berfungsi sebagai input bagi model rekomendasi untuk menghitung kesamaan antar item.

4. **Menampilkan Matriks TF-IDF**  
   - Matriks TF-IDF divisualisasikan dalam bentuk array
   - Hal ini memungkinkan pengguna memahami struktur data setelah representasi numerik.  

### **Kesimpulan**  
Proses **Data Preparation** ini merupakan tahap awal yang krusial dalam membangun sistem **Content-Based Filtering**. Langkah-langkahnya meliputi pembersihan data, transformasi teks menjadi representasi numerik, dan verifikasi hasil transformasi. Output dari tahapan ini akan digunakan dalam tahap berikutnya, seperti penghitungan kemiripan antar item untuk menghasilkan rekomendasi.

# 5. Modeling

## 5.1 Collaborative Filtering dengan Surprise
"""

# @title menggunakan SVD dari library surprise
model = SVD()

# Latih model dengan data training
model.fit(trainset)

# Evaluasi model pada data testing
predictions = model.test(testset)
print("\nHasil Evaluasi Model:")
mae_score = mae(predictions)
print(f"MAE: {mae_score:.4f}")

# 4. Fungsi Rekomendasi untuk Pengguna
def recommend_for_user(user_id, n=5):
    # Ambil semua movieId yang belum dirating oleh user
    rated_movies = ratings[ratings['userId'] == user_id]['movieId'].tolist()
    all_movies = ratings['movieId'].unique()
    unrated_movies = [movie for movie in all_movies if movie not in rated_movies]

    # Prediksi rating untuk film yang belum dirating
    predicted_ratings = [(movie, model.predict(user_id, movie).est) for movie in unrated_movies]

    # Urutkan film berdasarkan prediksi rating
    top_recommendations = sorted(predicted_ratings, key=lambda x: x[1], reverse=True)[:n]

    # Ambil judul film
    movie_titles = {row['movieId']: row['title'] for _, row in pd.read_csv('https://drive.google.com/uc?id=1eql1qRJzay8ZPHUbL5iJozTnfxtfQ3Fg').iterrows()}
    recommendations = [(movie_titles[movie], rating) for movie, rating in top_recommendations if movie in movie_titles]

    return recommendations

"""Untuk Collaborative filtering saya menggunakan SVD dari library surprise, saya memilih SVD dikarenakan kemampuan SVD
yang mampu mereduksi kompleksitas matriks besar menjadi komponen lebih kecil yang relevan.

Untuk Parameternnya saya menggunakan parameter default pada SVD

Berikut ini adalah metode colaborative filtering menggunakan SVD
"""

# Contoh rekomendasi untuk userId tertentu
user_id = 2
recommendations = recommend_for_user(user_id, n=5)
print(f"\nRekomendasi untuk User {user_id}:")
for i, (title, rating) in enumerate(recommendations):
    print(f"{i+1}. {title} (Predicted Rating: {rating:.2f})")

"""Terlihat pada hasil rekomendasi untuk user 2, model dapat merekomendasikan dan memprediksi rating dari user

## 5.2 Content-Based Filtering
"""

# @title Content-Based Filtering

# Hitung cosine similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
print("\nHasil kemiripan kosinus:")
print(cosine_sim)  # Menampilkan matriks kemiripan kosinus

# Fungsi untuk rekomendasi berbasis konten
def content_based_recommendation(title, n=5):
    # Ambil indeks film berdasarkan judul
    idx = movies[movies['title'] == title].index[0]

    # Ambil skor kemiripan dengan film input
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Ambil indeks film yang mirip
    sim_indices = [i[0] for i in sim_scores[1:n+1]]

    # Ambil judul film yang mirip
    return movies.iloc[sim_indices]['title'].tolist()

"""**Content-Based Filtering** adalah pendekatan dalam sistem rekomendasi yang menggunakan informasi dari fitur atau atribut item (seperti genre film) untuk merekomendasikan item serupa kepada pengguna. Dalam hal ini, algoritma mencari **kemiripan antara item** berdasarkan atribut yang relevan, tanpa memerlukan interaksi langsung dari pengguna.

---

### **Mengapa Menggunakan Content-Based Filtering?**

1. **Berdasarkan Preferensi Individual**:
   - Sistem ini sangat cocok ketika ingin merekomendasikan item yang mirip dengan item yang sudah diketahui pengguna.

2. **Tidak Bergantung pada Data Pengguna Lain**:
   - Tidak memerlukan data dari pengguna lain seperti pada collaborative filtering. Berguna untuk menghindari cold-start problem bagi pengguna baru.

3. **Mudah Diinterpretasi**:
   - Rekomendasi dapat dijelaskan karena berbasis pada atribut (misalnya, "Film ini direkomendasikan karena memiliki genre serupa dengan film sebelumnya").

---

### **Langkah-Langkah Implementasi**

#### 1. **Praproses Data Genre**
   ```python
   movies['genres'] = movies['genres'].str.replace('|', ' ')
   ```
   - Mengubah genre film menjadi format string yang bersih untuk diproses. Genre dipisahkan oleh spasi agar mudah dipahami oleh algoritma.

#### 2. **Representasi Data**
   - Data genre direpresentasikan dalam format yang memungkinkan algoritma menghitung kesamaan antar film.

#### 3. **Menghitung Kemiripan Antar Item**
   ```python
   from sklearn.metrics.pairwise import cosine_similarity
   cosine_sim = cosine_similarity(matrix, matrix)
   ```
   - **Apa itu Cosine Similarity?**
     - Cosine similarity mengukur kemiripan antara dua vektor dengan menghitung kosinus sudut di antara mereka. Nilai berkisar antara 0 (tidak mirip) hingga 1 (sangat mirip).
   - **Mengapa Cosine Similarity?**
     - Cocok untuk menghitung kesamaan antar representasi data karena mempertimbangkan hubungan proporsional antar atribut.

#### 4. **Mencari Rekomendasi**
   - **Proses:**
     - Ambil indeks film input.
     - Hitung skor kemiripan dengan semua film lainnya.
     - Urutkan film berdasarkan skor kemiripan tertinggi.
     - Pilih 10 film dengan skor kemiripan tertinggi (selain film input).

---

### **Keunggulan dan Kekurangan**

#### **Keunggulan:**
1. Tidak membutuhkan interaksi pengguna lain (cocok untuk cold-start problem bagi pengguna baru).
2. Mudah diinterpretasi (rekomendasi berbasis atribut item).

#### **Kekurangan:**
1. Tidak dapat merekomendasikan item dengan atribut yang belum pernah dilihat oleh pengguna.
2. Tidak menangkap aspek non-atribut seperti popularitas atau pola perilaku pengguna lainnya.

---

Dengan pendekatan ini, sistem fokus pada memanfaatkan **genre** film untuk menghasilkan rekomendasi yang relevan, menjadikannya efektif untuk menemukan item serupa secara konten.
"""

# Contoh rekomendasi
print("\nRekomendasi untuk Toy Story (1995):")
recommendations = content_based_recommendation("Toy Story (1995)", n=5)
for i, rec in enumerate(recommendations):
    print(f"{i+1}. {rec}")

"""Terlihat model sudah dapat merekomendasikan film berdasarkan kesamaan gendre

Insight :

Sistem rekomendasi ini menggunakan pendekatan content-based dengan memanfaatkan fitur genre film. Model mencari film dengan genre yang mirip dengan film yang disukai pengguna. Dalam hal ini, sistem merekomendasikan film yang mirip dengan Toy Story (1995) berdasarkan kemiripan genre.


![image.png](data:image/png;base64,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)


Model berhasil merekomendasikan film dengan genre serupa, menunjukkan efektivitas pendekatan berbasis konten.

# 5. Evaluation

## 5.1 Colaborative filtering
"""

from surprise.model_selection import cross_validate
from surprise import accuracy

# Evaluasi model dengan RMSE
predictions = model.test(testset)
rmse = accuracy.rmse(predictions)

print(f"RMSE: {rmse}")

# Evaluasi dengan Cross Validation
cv_results = cross_validate(model, data, measures=['RMSE', 'MAE'], cv=5, verbose=True)

# Rata-rata RMSE
mean_rmse = cv_results['test_rmse'].mean()
print(f"Mean RMSE from Cross-Validation: {mean_rmse}")

"""Untuk evaluasi Collaborative filtering saya menggunakan RMSE, MAE, dan Cross validation.

- RMSE: 0.8727 pada satu kali evaluasi menunjukkan model dapat memprediksi rating dengan kesalahan yang relatif kecil.
- MAE pada beberapa lipatan evaluasi berada di sekitar 0.6706, yang mendukung kesimpulan bahwa model bekerja dengan baik.
- Hasil rata-rata RMSE dari Cross-Validation: 0.8729, dengan standar deviasi 0.0067, menunjukkan bahwa model bekerja secara konsisten di berbagai subset data.

## 5.2 Content base filtering
"""

from sklearn.metrics import precision_score, recall_score

def evaluate_content_based_precision_recall(title, recommendations):
    # Ambil genre film asli
    original_genres = set(movies[movies['title'] == title]['genres'].values[0].split('|'))

    true_positives = 0
    false_positives = 0
    false_negatives = 0

    print(f"\nOriginal Movie: {title}")
    print(f"Genres: {original_genres}\n")

    for rec in recommendations:
        rec_movie = movies[movies['title'] == rec]
        rec_genres = set(rec_movie['genres'].values[0].split('|'))

        # Menentukan apakah genre film yang direkomendasikan relevan (TP atau FP)
        if len(original_genres.intersection(rec_genres)) > 0:
            true_positives += 1
        else:
            false_positives += 1

        # Menentukan apakah genre film yang seharusnya direkomendasikan ada (FN)
        if len(original_genres.difference(rec_genres)) > 0:
            false_negatives += 1

        print(f"Recommended Movie: {rec}")
        print(f"Genres: {rec_genres}")
        print(f"Is Relevant? {'Yes' if len(original_genres.intersection(rec_genres)) > 0 else 'No'}\n")

    # Menghitung precision dan recall
    precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0
    recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0

    print(f"Precision: {precision:.2f}")
    print(f"Recall: {recall:.2f}")

    return precision, recall

# Evaluasi rekomendasi
precision, recall = evaluate_content_based_precision_recall("Toy Story (1995)", recommendations)
print(f"\nRata-rata Precision: {precision:.2f}")
print(f"Rata-rata Recall: {recall:.2f}")

"""Hasil Evaluasi menggunakan precision dan recall ini menunjukkan bahwa model Content-Based Filtering sangat efektif dalam merekomendasikan film dengan genre yang sesuai.

Hal ini mengindikasikan bahwa pendekatan yang digunakan, yaitu dengan menghitung kemiripan berdasarkan TF-IDF genre, berhasil menangkap hubungan yang relevan di antara film-film dalam dataset.

Model sistem rekomendasi dikembangkan dengan dua pendekatan: content-based filtering dan collaborative filtering. Pada pendekatan content-based, sistem menggunakan kesamaan genre untuk merekomendasikan film yang relevan. Contohnya, ketika pengguna memilih "Toy Story (1995)", sistem berhasil merekomendasikan lima film lain yang memiliki genre serupa, seperti "Antz (1998)" dan "Toy Story 2 (1999)", dengan hasil evaluasi precision dan recall sebesar 1.00, menunjukkan bahwa seluruh rekomendasi relevan terhadap preferensi genre pengguna.

Sementara itu, pada pendekatan collaborative filtering menggunakan algoritma SVD, evaluasi dilakukan dengan metrik RMSE, MAE, dan cross-validation. Hasil menunjukkan bahwa model mampu memprediksi rating dengan baik, dengan nilai RMSE sebesar 0.8727 dan MAE sekitar 0.6706. Rata-rata RMSE dari cross-validation sebesar 0.8729 dengan standar deviasi rendah (0.0067), menandakan bahwa model bekerja konsisten pada berbagai subset data. Kedua pendekatan ini menunjukkan performa yang baik dalam memberikan rekomendasi yang akurat dan relevan.
"""